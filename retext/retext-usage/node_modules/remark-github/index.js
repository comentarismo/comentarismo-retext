/**
 * @author Titus Wormer
 * @copyright 2015 Titus Wormer
 * @license MIT
 * @module remark:github
 * @fileoverview
 *   Auto-link references like in GitHub issues, PRs,
 *   and comments.
 */

'use strict';

/* global global */

/* eslint-env commonjs */

/*
 * Constants.
 */

var GIT_SUFFIX = '.git';
var GH_ISSUE_PREFIX = 'gh-';
var COMMITS = 'commit/';
var ISSUES = 'issues/';
var MAX_SHA_LENGTH = 40;
var MIN_SHA_LENGTH = 7;
var MAX_USER_LENGTH = 39;
var MAX_PROJECT_LENGTH = 100;

/*
 * Characters.
 */

var C_SLASH = '/';
var C_HASH = '#';
var C_AT = '@';

/*
 * Character codes.
 */

var CC_0 = '0'.charCodeAt(0);
var CC_9 = '9'.charCodeAt(0);
var CC_A_LOWER = 'a'.charCodeAt(0);
var CC_F_LOWER = 'f'.charCodeAt(0);
var CC_Z_LOWER = 'z'.charCodeAt(0);
var CC_A_UPPER = 'A'.charCodeAt(0);
var CC_F_UPPER = 'F'.charCodeAt(0);
var CC_Z_UPPER = 'Z'.charCodeAt(0);
var CC_SLASH = C_SLASH.charCodeAt(0);
var CC_DOT = '.'.charCodeAt(0);
var CC_DASH = '-'.charCodeAt(0);
var CC_HASH = C_HASH.charCodeAt(0);
var CC_AT = C_AT.charCodeAt(0);

/*
 * Blacklist of SHAs which are also valid words.
 *
 * GitHub allows abbreviating SHAs up to 7 characters.
 * These are ignored in text because they might just be
 * ment as normal words.  If youâ€™d like these to link to
 * their SHAs, just use more than 7 characters.
 *
 * Generated by:
 *
 *     egrep -i "^[a-f0-9]{7,}$" /usr/share/dict/words
 */

var BLACKLIST = [
    'deedeed',
    'fabaceae'
];

/*
 * Map of overwrites for at-mentions.
 * GitHub does some fancy stuff with `@mention`, by linking
 * it to their blog-post introducing the feature.
 * To my knowledge, there are no other magical usernames.
 */

var OVERWRITES = {};

OVERWRITES.mentions = OVERWRITES.mention = 'blog/821';

/*
 * Cached method.
 */

var has = Object.prototype.hasOwnProperty;

/*
 * Hide process use from browserify.
 */

var proc = typeof global !== 'undefined' && global.process;

/**
 * Check if a value is a SHA.
 *
 * @param {string} sha - Commit hash.
 * @return {boolean} - Whether `sha` is not blacklisted.
 */
function isSHA(sha) {
    return BLACKLIST.indexOf(sha.toLowerCase()) === -1;
}

/**
 * Abbreviate a SHA.
 *
 * @param {string} sha - Commit hash.
 * @return {string} - Abbreviated sha.
 */
function abbr(sha) {
    return sha.slice(0, 7);
}

/**
 * Return a URL to GitHub, relative to an optional
 * `repo` object, or `user` and `project`.
 *
 * @param {Object|string?} repo - Repository.
 * @param {string?} project - Project.
 * @return {string} - URL.
 */
function gh(repo, project) {
    var base = 'https://github.com/';

    if (project) {
        repo = {
            'user': repo,
            'project': project
        };
    }

    if (repo) {
        base += repo.user + C_SLASH + repo.project + C_SLASH;
    }

    return base;
}

/*
 * Username may only contain alphanumeric characters or
 * single hyphens, and cannot begin or end with a hyphen.
 *
 * `PERSON` is either a user or an organization, but also
 * matches a team:
 *
 *   https://github.com/blog/1121-introducing-team-mentions
 */

var NAME = '(?:[a-z0-9]{1,2}|[a-z0-9][a-z0-9-]{1,37}[a-z0-9])';
var USER = '(' + NAME + ')';
var PROJECT = '((?:[a-z0-9-]|\\.git[a-z0-9-]|\\.(?!git))+)';
var REPO = USER + '\\/' + PROJECT;

/*
 * Match a repo from a git / github URL.
 */

var REPOSITORY = new RegExp(
    '(?:^|/(?:repos/)?)' + REPO + '(?=\\.git|[\\/#@]|$)', 'i'
);

/**
 * Check whether `code` is a hexadecimal character.
 *
 * @param {number} code - Single character code to check.
 * @return {boolean} - Whether or not `code` is a valid
 *   hexadecimal character.
 */
function isHexadecimal(code) {
    return (code >= CC_0 && code <= CC_9) ||
        (code >= CC_A_LOWER && code <= CC_F_LOWER) ||
        (code >= CC_A_UPPER && code <= CC_F_UPPER);
}

/**
 * Check whether `code` is a decimal character.
 *
 * @param {number} code - Single character code to check.
 * @return {boolean} - Whether or not `code` is a valid
 *   decimal character.
 */
function isDecimal(code) {
    return code >= CC_0 && code <= CC_9;
}

/**
 * Check whether `code` is a repo character.
 *
 * @param {number} code - Single character code to check.
 * @return {boolean} - Whether or not `code` is a valid
 *   repo character.
 */
function isValidRepoCharacter(code) {
    return code === CC_SLASH ||
        code === CC_DOT ||
        code === CC_DASH ||
        (code >= CC_0 && code <= CC_9) ||
        (code >= CC_A_LOWER && code <= CC_Z_LOWER) ||
        (code >= CC_A_UPPER && code <= CC_Z_UPPER);
}

/**
 * Check whether `code` is a valid project name character.
 *
 * @param {number} code - Single character code to check.
 * @return {boolean} - Whether or not `code` is a valid
 *   project name character.
 */
function isValidProjectNameCharacter(code) {
    return code === CC_DOT ||
        code === CC_DASH ||
        (code >= CC_0 && code <= CC_9) ||
        (code >= CC_A_LOWER && code <= CC_Z_LOWER) ||
        (code >= CC_A_UPPER && code <= CC_Z_UPPER);
}

/**
 * Check whether `code` is a valid username character.
 *
 * @param {number} code - Single character code to check.
 * @return {boolean} - Whether or not `code` is a valid
 *   username character.
 */
function isValidUserNameCharacter(code) {
    return code === CC_DASH ||
        (code >= CC_0 && code <= CC_9) ||
        (code >= CC_A_LOWER && code <= CC_Z_LOWER) ||
        (code >= CC_A_UPPER && code <= CC_Z_UPPER);
}

/**
 * Create a bound regex locator.
 *
 * @example
 *   regexLocatorFactory(/-/g);
 *
 * @param {RegExp} regex - Expressions to bind to.
 * @return {Function} - Locator.
 */
function regexLocatorFactory(regex) {
    /**
     * Find the place where a regex begins.
     *
     * @example
     *   regexLocatorFactory(/-/g)('foo - bar'); // 4
     *
     * @param {string} value - Value to search.
     * @param {number} fromIndex - Index to start searching at.
     * @return {number} - Location of match.
     */
    function locator(value, fromIndex) {
        var result;
        var prev;

        regex.lastIndex = fromIndex;

        result = regex.exec(value);

        if (result) {
            result = regex.lastIndex - result[0].length;
            prev = value.charCodeAt(result - 1);

            if (
                isValidUserNameCharacter(prev) ||
                prev === CC_HASH ||
                prev === CC_AT
            ) {
                /* Find the next possible value. */
                return locator(value, regex.lastIndex);
            }

            return result;
        }

        return -1;
    }

    return locator;
}

/**
 * Tokenise a hash.
 *
 * @example
 *   tokenizeHash(eat, 'bada555');
 *
 * @property {boolean} notInLink - Disable nested links.
 * @property {Function} locator - Hash locator.
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `link` node.
 */
function tokenizeHash(eat, value, silent) {
    var self = this;
    var index = 0;
    var length = value.length;
    var subvalue;
    var href;
    var now;
    var node;

    if (length > MAX_SHA_LENGTH) {
        length = MAX_SHA_LENGTH;
    }

    while (index < length) {
        if (!isHexadecimal(value.charCodeAt(index))) {
            break;
        }

        index++;
    }

    if (
        index < MIN_SHA_LENGTH ||
        (index === length && isHexadecimal(value.charCodeAt(index)))
    ) {
        return;
    }

    subvalue = value.slice(0, index);

    if (!isSHA(subvalue)) {
        return;
    }

    /* istanbul ignore if - maybe used by plug-ins */
    if (silent) {
        return true;
    }

    href = gh(self.github) + 'commit/' + subvalue;
    now = eat.now();

    node = eat(subvalue)(
        self.renderLink(true, href, subvalue, null, now, eat)
    );

    node.children = [{
        'type': 'inlineCode',
        'value': abbr(subvalue),
        'position': node.children[0].position
    }];

    return node;
}

tokenizeHash.locator = regexLocatorFactory(/\b[a-f0-9]{7,40}\b/gi);
tokenizeHash.notInLink = true;

/**
 * Find a possible mention.
 *
 * @example
 *   locateMention('foo @bar'); // 4
 *
 * @param {string} value - Value to search.
 * @param {number} fromIndex - Index to start searching at.
 * @return {number} - Location of possible mention.
 */
function locateMention(value, fromIndex) {
    var index = value.indexOf(C_AT, fromIndex);

    if (
        index !== -1 &&
        isValidRepoCharacter(value.charCodeAt(index - 1))
    ) {
        return locateMention(value, index + 1);
    }

    return index;
}

/**
 * Tokenise a mention.
 *
 * @example
 *   tokenizeMention(eat, '@baz');
 *
 * @property {boolean} notInLink - Disable nested links.
 * @property {Function} locator - Mention locator.
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `link` node.
 */
function tokenizeMention(eat, value, silent) {
    var self = this;
    var index;
    var length;
    var slash;
    var code;
    var subvalue;
    var handle;
    var href;
    var node;
    var now;

    if (
        value.charCodeAt(0) !== CC_AT ||
        value.charCodeAt(1) === CC_DASH
    ) {
        return;
    }

    slash = -1;
    length = value.length;
    index = 1;

    while (index < length) {
        code = value.charCodeAt(index);

        if (code === CC_SLASH) {
            if (slash !== -1) {
                break;
            }

            slash = index;

            if (
                value.charCodeAt(index - 1) === CC_DASH ||
                value.charCodeAt(index + 1) === CC_DASH
            ) {
                return;
            }
        } else if (!isValidUserNameCharacter(code)) {
            break;
        }

        index++;
    }

    if (
        value.charCodeAt(index - 1) === CC_DASH ||
        index > MAX_USER_LENGTH + 1
    ) {
        return;
    }

    /* istanbul ignore if - maybe used by plug-ins */
    if (silent) {
        return true;
    }

    now = eat.now();
    handle = value.slice(1, index);
    subvalue = C_AT + handle;

    href = gh();
    href += has.call(OVERWRITES, handle) ? OVERWRITES[handle] : handle;

    now.column++;

    node = eat(subvalue)(self.renderLink(
        true, href, subvalue, null, now, eat
    ));

    node.children = [{
        'type': 'strong',
        'children': node.children
    }];

    return node;
}

tokenizeMention.locator = locateMention;
tokenizeMention.notInLink = true;

/**
 * Tokenise an issue.
 *
 * @example
 *   tokenizeIssue(eat, 'GH-1');
 *   tokenizeIssue(eat, '#3');
 *
 * @property {boolean} notInLink - Disable nested links.
 * @property {Function} locator - Issue locator.
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `link` node.
 */
function tokenizeIssue(eat, value, silent) {
    var self = this;
    var index;
    var length;
    var start;
    var subvalue;
    var href;
    var now;

    if (value.charCodeAt(0) === CC_HASH) {
        index = 1;
    } else if (
        value.slice(0, GH_ISSUE_PREFIX.length).toLowerCase() ===
        GH_ISSUE_PREFIX
    ) {
        index = GH_ISSUE_PREFIX.length;
    } else {
        return;
    }

    start = index;
    length = value.length;

    while (index < length) {
        if (!isDecimal(value.charCodeAt(index))) {
            break;
        }

        index++;
    }

    if (index === start) {
        return;
    }

    /* istanbul ignore if - maybe used by plug-ins */
    if (silent) {
        return true;
    }

    now = eat.now();
    href = gh(self.github) + ISSUES + value.slice(start, index);
    subvalue = value.slice(0, index);

    now.column += start;

    return eat(subvalue)(
        self.renderLink(true, href, subvalue, null, now, eat)
    );
}

tokenizeIssue.locator = regexLocatorFactory(/\bgh-|#/gi);
tokenizeIssue.notInLink = true;

/**
 * Find a possible reference.
 *
 * @example
 *   locateRepoReference('foo bar/baz#1'); // 4
 *
 * @param {string} value - Value to search.
 * @param {number} fromIndex - Index to start searching at.
 * @return {number} - Location of possible reference.
 */
function locateRepoReference(value, fromIndex) {
    var hash = value.indexOf(C_AT, fromIndex);
    var issue = value.indexOf(C_HASH, fromIndex);
    var index;
    var start;
    var test;

    if (hash === -1) {
        index = issue;
    } else if (issue === -1) {
        index = hash;
    } else {
        index = (hash > issue ? issue : hash);
    }

    start = index;

    if (start === -1) {
        return index;
    }

    while (index >= fromIndex) {
        if (!isValidRepoCharacter(value.charCodeAt(index - 1))) {
            break;
        }

        index--;
    }

    if (index < start && index >= fromIndex) {
        test = start === hash ? isHexadecimal : isDecimal;

        if (
            test(value.charCodeAt(start + 1)) &&
            !isValidRepoCharacter(value.charCodeAt(index - 1))
        ) {
            return index;
        }
    }

    /* Find the next possible value. */
    return locateRepoReference(value, start + 1);
}

/**
 * Tokenise a reference.
 *
 * @example
 *   tokenizeRepoReference(eat, 'foo@bada555');
 *
 * @property {boolean} notInLink - Disable nested links.
 * @property {Function} locator - Reference locator.
 * @param {function(string)} eat - Eater.
 * @param {string} value - Rest of content.
 * @param {boolean?} [silent] - Whether this is a dry run.
 * @return {Node?|boolean} - `link` node.
 */
function tokenizeRepoReference(eat, value, silent) {
    var self = this;
    var delimiter;
    var href;
    var index = 0;
    var length = value.length;
    var code;
    var handle;
    var handleEnd;
    var project;
    var projectStart;
    var projectEnd;
    var referenceStart;
    var reference;
    var subvalue;
    var test;
    var suffix;
    var now;
    var content;
    var node;
    var add;

    /* First character of username cannot be a dash. */
    if (value.charCodeAt(index) === CC_DASH) {
        return;
    }

    while (index < length) {
        if (!isValidUserNameCharacter(value.charCodeAt(index))) {
            break;
        }

        index++;
    }

    /* Last character of username cannot be a dash. */
    if (value.charCodeAt(index - 1) === CC_DASH) {
        return;
    }

    code = value.charCodeAt(index);

    /* Last character of username cannot be a dash. */
    if (!index || index > MAX_USER_LENGTH) {
        return;
    }

    handleEnd = index;

    if (code === CC_SLASH) {
        index++;
        projectStart = index;

        while (index < length) {
            if (!isValidProjectNameCharacter(value.charCodeAt(index))) {
                break;
            }

            index++;
        }

        if (
            (index - projectStart) > MAX_PROJECT_LENGTH ||
            (value.slice(index - GIT_SUFFIX.length, index) === GIT_SUFFIX)
        ) {
            return;
        }

        projectEnd = index;
    }

    code = value.charCodeAt(index);

    if (code === CC_HASH) {
        test = isDecimal;
        suffix = ISSUES;
    } else if (code === CC_AT) {
        test = isHexadecimal;
        suffix = COMMITS;
    } else {
        return;
    }

    delimiter = value.charAt(index);
    index++;
    referenceStart = index;

    while (index < length) {
        if (!test(value.charCodeAt(index))) {
            if (isValidUserNameCharacter(value.charCodeAt(index))) {
                return;
            }

            break;
        }

        index++;
    }

    reference = value.slice(referenceStart, index);
    content = reference;

    if (
        suffix === COMMITS &&
        (
            reference.length < MIN_SHA_LENGTH ||
            reference.length > MAX_SHA_LENGTH
        )
    ) {
        reference = null;
    }

    if (!reference) {
        return;
    }

    /* istanbul ignore if - maybe used by plug-ins */
    if (silent) {
        return true;
    }

    handle = value.slice(0, handleEnd);
    project = projectEnd && value.slice(projectStart, projectEnd);
    href = gh(handle, project || self.github.project) + suffix + reference;
    subvalue = value.slice(0, index);
    handle += (project ? C_SLASH + project : '') + delimiter;
    add = eat(subvalue);

    if (suffix === COMMITS) {
        node = add(self.renderLink(true, href, handle, null, now, eat));

        node.children.push({
            'type': 'inlineCode',
            'value': abbr(content)
        });

        return node;
    }

    return add(self.renderLink(true, href, handle + content, null, now, eat));
}

tokenizeRepoReference.locator = locateRepoReference;
tokenizeRepoReference.notInLink = true;

/**
 * Attacher.
 *
 * @param {Remark} remark - Instance.
 * @param {Object?} [options] - Configuration.
 */
function attacher(remark, options) {
    var repo = (options || {}).repository;
    var proto = remark.Parser.prototype;
    var scope = proto.inlineTokenizers;
    var methods = proto.inlineMethods;
    var pack;

    /*
     * Get the repo from `package.json`.
     */

    if (!repo) {
        try {
            pack = require(require('path').resolve(
                proc.cwd(), 'package.json'
            ));
        } catch (exception) {
            pack = {};
        }

        repo = pack.repository ? pack.repository.url || pack.repository : '';
    }

    /*
     * Parse the URL.
     * See the tests for all possible URL kinds.
     */

    repo = REPOSITORY.exec(repo);

    REPOSITORY.lastIndex = 0;

    if (!repo) {
        throw new Error('Missing `repository` field in `options`');
    }

    repo = {
        'user': repo[1],
        'project': repo[2]
    };

    /*
     * Add tokenizers to the `Parser`.
     */

    scope.mention = tokenizeMention;
    scope.issue = tokenizeIssue;
    scope.hash = tokenizeHash;
    scope.repoReference = tokenizeRepoReference;

    proto.github = repo;

    /*
     * Specify order (just before `inlineText`).
     */

    methods.splice(methods.indexOf('inlineText'), 0,
        'mention',
        'issue',
        'hash',
        'repoReference'
    );
}

/*
 * Expose.
 */

module.exports = attacher;
