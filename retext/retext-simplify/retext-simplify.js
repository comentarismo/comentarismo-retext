(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.retextSimplify = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports={
  "a number of": {
    "replace": [
      "many",
      "some"
    ]
  },
  "abundance": {
    "replace": [
      "enough",
      "plenty"
    ]
  },
  "accede to": {
    "replace": [
      "agree to",
      "allow"
    ]
  },
  "accelerate": {
    "replace": [
      "speed up"
    ]
  },
  "accentuate": {
    "replace": [
      "stress"
    ]
  },
  "accompany": {
    "replace": [
      "go with",
      "with"
    ]
  },
  "accomplish": {
    "replace": [
      "carry out",
      "do"
    ]
  },
  "accorded": {
    "replace": [
      "given"
    ]
  },
  "accordingly": {
    "replace": [
      "so"
    ]
  },
  "accrue": {
    "replace": [
      "add",
      "gain"
    ]
  },
  "accurate": {
    "replace": [
      "correct",
      "exact",
      "right"
    ]
  },
  "acquiesce": {
    "replace": [
      "agree"
    ]
  },
  "acquire": {
    "replace": [
      "get"
    ]
  },
  "additional": {
    "replace": [
      "added",
      "extra",
      "more",
      "other"
    ]
  },
  "address": {
    "replace": [
      "discuss"
    ]
  },
  "addressees": {
    "replace": [
      "you"
    ]
  },
  "addressees are requested": {
    "omit": true,
    "replace": [
      "please"
    ]
  },
  "adjacent to": {
    "replace": [
      "next to"
    ]
  },
  "adjustment": {
    "replace": [
      "change"
    ]
  },
  "admissible": {
    "replace": [
      "accepted",
      "allowed"
    ]
  },
  "advantageous": {
    "replace": [
      "helpful"
    ]
  },
  "adversely impact": {
    "replace": [
      "hurt"
    ]
  },
  "adversely impact on": {
    "replace": [
      "hurt",
      "set back"
    ]
  },
  "advise": {
    "replace": [
      "recommend",
      "tell"
    ]
  },
  "afford an opportunity": {
    "replace": [
      "allow",
      "let"
    ]
  },
  "aforementioned": {
    "replace": [
      "remove"
    ]
  },
  "aggregate": {
    "replace": [
      "add",
      "total"
    ]
  },
  "aircraft": {
    "replace": [
      "plane"
    ]
  },
  "all of": {
    "replace": [
      "all"
    ]
  },
  "alleviate": {
    "replace": [
      "ease",
      "reduce"
    ]
  },
  "allocate": {
    "replace": [
      "divide"
    ]
  },
  "along the lines of": {
    "replace": [
      "as in",
      "like"
    ]
  },
  "already existing": {
    "replace": [
      "existing"
    ]
  },
  "alternatively": {
    "replace": [
      "or"
    ]
  },
  "ameliorate": {
    "replace": [
      "help",
      "improve"
    ]
  },
  "and/or": {
    "replace": [
      "… or … or both"
    ]
  },
  "anticipate": {
    "replace": [
      "expect"
    ]
  },
  "apparent": {
    "replace": [
      "clear",
      "plain"
    ]
  },
  "appreciable": {
    "replace": [
      "many"
    ]
  },
  "appropriate": {
    "omit": true,
    "replace": [
      "proper",
      "right"
    ]
  },
  "approximate": {
    "replace": [
      "about"
    ]
  },
  "arrive onboard": {
    "replace": [
      "arrive"
    ]
  },
  "as a means of": {
    "replace": [
      "to"
    ]
  },
  "as of yet": {
    "replace": [
      "yet"
    ]
  },
  "as prescribed by": {
    "replace": [
      "in"
    ]
  },
  "as to": {
    "replace": [
      "about",
      "on"
    ]
  },
  "as yet": {
    "replace": [
      "yet"
    ]
  },
  "ascertain": {
    "replace": [
      "find out",
      "learn"
    ]
  },
  "assist": {
    "replace": [
      "aid",
      "help"
    ]
  },
  "assistance": {
    "replace": [
      "aid",
      "help"
    ]
  },
  "at the present time": {
    "replace": [
      "at present"
    ]
  },
  "at this time": {
    "replace": [
      "now"
    ]
  },
  "attain": {
    "replace": [
      "meet"
    ]
  },
  "attempt": {
    "replace": [
      "try"
    ]
  },
  "attributable to": {
    "replace": [
      "because"
    ]
  },
  "authorise": {
    "replace": [
      "allow",
      "let"
    ]
  },
  "authorize": {
    "replace": [
      "allow",
      "let"
    ]
  },
  "be advised": {
    "omit": true,
    "replace": []
  },
  "because of the fact that": {
    "replace": [
      "because"
    ]
  },
  "belated": {
    "replace": [
      "late"
    ]
  },
  "benefit": {
    "replace": [
      "help"
    ]
  },
  "benefit from": {
    "replace": [
      "enjoy"
    ]
  },
  "bestow": {
    "replace": [
      "award",
      "give"
    ]
  },
  "by means of": {
    "replace": [
      "by",
      "with"
    ]
  },
  "by virtue of": {
    "replace": [
      "by",
      "under"
    ]
  },
  "capability": {
    "replace": [
      "ability"
    ]
  },
  "caveat": {
    "replace": [
      "warning"
    ]
  },
  "cease": {
    "replace": [
      "stop"
    ]
  },
  "close proximity": {
    "replace": [
      "near"
    ]
  },
  "combat environment": {
    "replace": [
      "combat"
    ]
  },
  "combined": {
    "replace": [
      "joint"
    ]
  },
  "commence": {
    "replace": [
      "begin",
      "start"
    ]
  },
  "comply with": {
    "replace": [
      "follow"
    ]
  },
  "component": {
    "replace": [
      "part"
    ]
  },
  "comprise": {
    "replace": [
      "form",
      "include",
      "make up"
    ]
  },
  "concerning": {
    "replace": [
      "about",
      "on"
    ]
  },
  "consequently": {
    "replace": [
      "so"
    ]
  },
  "consolidate": {
    "replace": [
      "combine",
      "join",
      "merge"
    ]
  },
  "constitutes": {
    "replace": [
      "forms",
      "is",
      "makes up"
    ]
  },
  "contains": {
    "replace": [
      "has"
    ]
  },
  "convene": {
    "replace": [
      "meet"
    ]
  },
  "currently": {
    "omit": true,
    "replace": [
      "now"
    ]
  },
  "deem": {
    "replace": [
      "believe",
      "consider",
      "think"
    ]
  },
  "delete": {
    "replace": [
      "cut",
      "drop"
    ]
  },
  "demonstrate": {
    "replace": [
      "prove",
      "show"
    ]
  },
  "depart": {
    "replace": [
      "go",
      "leave"
    ]
  },
  "designate": {
    "replace": [
      "appoint",
      "choose",
      "name"
    ]
  },
  "desire": {
    "replace": [
      "want",
      "wish"
    ]
  },
  "determine": {
    "replace": [
      "decide",
      "figure",
      "find"
    ]
  },
  "disclose": {
    "replace": [
      "show"
    ]
  },
  "discontinue": {
    "replace": [
      "drop",
      "stop"
    ]
  },
  "disseminate": {
    "replace": [
      "give",
      "issue",
      "pass",
      "send"
    ]
  },
  "due to the fact that": {
    "replace": [
      "because",
      "due to",
      "since"
    ]
  },
  "during the period": {
    "replace": [
      "during"
    ]
  },
  "e.g.": {
    "replace": [
      "for example",
      "such as"
    ]
  },
  "each and every": {
    "replace": [
      "each"
    ]
  },
  "economical": {
    "replace": [
      "cheap"
    ]
  },
  "effect": {
    "replace": [
      "choose",
      "pick"
    ]
  },
  "effect modifications": {
    "replace": [
      "make changes"
    ]
  },
  "elect": {
    "replace": [
      "choose"
    ]
  },
  "eliminate": {
    "replace": [
      "cut",
      "drop",
      "end",
      "stop"
    ]
  },
  "elucidate": {
    "replace": [
      "explain"
    ]
  },
  "employ": {
    "replace": [
      "use"
    ]
  },
  "encounter": {
    "replace": [
      "meet"
    ]
  },
  "endeavor": {
    "replace": [
      "try"
    ]
  },
  "ensure": {
    "replace": [
      "make sure"
    ]
  },
  "enumerate": {
    "replace": [
      "count"
    ]
  },
  "equipments": {
    "replace": [
      "equipment"
    ]
  },
  "equitable": {
    "replace": [
      "fair"
    ]
  },
  "equivalent": {
    "replace": [
      "equal"
    ]
  },
  "establish": {
    "replace": [
      "set up",
      "prove",
      "show"
    ]
  },
  "evaluate": {
    "replace": [
      "check",
      "test"
    ]
  },
  "evidenced": {
    "replace": [
      "showed"
    ]
  },
  "evident": {
    "replace": [
      "clear"
    ]
  },
  "exclusively": {
    "replace": [
      "only"
    ]
  },
  "exhibit": {
    "replace": [
      "show"
    ]
  },
  "expedite": {
    "replace": [
      "hasten",
      "hurry",
      "speed up"
    ]
  },
  "expeditious": {
    "replace": [
      "fast",
      "quick"
    ]
  },
  "expend": {
    "replace": [
      "spend"
    ]
  },
  "expertise": {
    "replace": [
      "ability"
    ]
  },
  "expiration": {
    "replace": [
      "end"
    ]
  },
  "facilitate": {
    "replace": [
      "ease",
      "help"
    ]
  },
  "factual evidence": {
    "replace": [
      "evidence",
      "facts"
    ]
  },
  "failed to": {
    "replace": [
      "didn’t"
    ]
  },
  "feasible": {
    "replace": [
      "can be done",
      "workable"
    ]
  },
  "females": {
    "replace": [
      "women"
    ]
  },
  "finalise": {
    "replace": [
      "complete",
      "finish"
    ]
  },
  "finalise": {
    "replace": [
      "complete",
      "finish"
    ]
  },
  "finalize": {
    "replace": [
      "complete",
      "finish"
    ]
  },
  "first and foremost": {
    "replace": [
      "first"
    ]
  },
  "for a period of": {
    "replace": [
      "for"
    ]
  },
  "for the purpose of": {
    "replace": [
      "to"
    ]
  },
  "forfeit": {
    "replace": [
      "give up",
      "lose"
    ]
  },
  "formulate": {
    "replace": [
      "plan"
    ]
  },
  "forward": {
    "replace": [
      "send"
    ]
  },
  "frequently": {
    "replace": [
      "often"
    ]
  },
  "function": {
    "replace": [
      "act",
      "role",
      "work"
    ]
  },
  "furnish": {
    "replace": [
      "give",
      "send"
    ]
  },
  "has a requirement for": {
    "replace": [
      "needs"
    ]
  },
  "herein": {
    "replace": [
      "here"
    ]
  },
  "heretofore": {
    "replace": [
      "until now"
    ]
  },
  "herewith": {
    "replace": [
      "here",
      "below"
    ]
  },
  "honest truth": {
    "replace": [
      "truth"
    ]
  },
  "however": {
    "replace": [
      "but",
      "yet"
    ]
  },
  "i.e.": {
    "replace": [
      "as in"
    ]
  },
  "identical": {
    "replace": [
      "same"
    ]
  },
  "identify": {
    "replace": [
      "find",
      "name",
      "show"
    ]
  },
  "if and when": {
    "replace": [
      "if",
      "when"
    ]
  },
  "immediately": {
    "replace": [
      "at once"
    ]
  },
  "impacted": {
    "replace": [
      "affected",
      "changed",
      "harmed"
    ]
  },
  "implement": {
    "replace": [
      "carry out",
      "install",
      "put in place",
      "tool",
      "start"
    ]
  },
  "in a timely manner": {
    "replace": [
      "on time",
      "promptly"
    ]
  },
  "in accordance with": {
    "replace": [
      "by",
      "under",
      "following",
      "per"
    ]
  },
  "in addition": {
    "replace": [
      "also",
      "besides",
      "too"
    ]
  },
  "in all likelihood": {
    "replace": [
      "probably"
    ]
  },
  "in an effort to": {
    "replace": [
      "to"
    ]
  },
  "in between": {
    "replace": [
      "between"
    ]
  },
  "in excess of": {
    "replace": [
      "more than"
    ]
  },
  "in lieu of": {
    "replace": [
      "instead"
    ]
  },
  "in light of the fact that": {
    "replace": [
      "because"
    ]
  },
  "in many cases": {
    "replace": [
      "often"
    ]
  },
  "in order that": {
    "replace": [
      "for",
      "so"
    ]
  },
  "in order to": {
    "replace": [
      "to"
    ]
  },
  "in regard to": {
    "replace": [
      "about",
      "concerning",
      "on"
    ]
  },
  "in relation to": {
    "replace": [
      "about",
      "with",
      "to"
    ]
  },
  "in some instances": {
    "replace": [
      "sometimes"
    ]
  },
  "in terms of": {
    "omit": true,
    "replace": [
      "as",
      "for",
      "with"
    ]
  },
  "in the amount of": {
    "replace": [
      "for"
    ]
  },
  "in the event of": {
    "replace": [
      "if"
    ]
  },
  "in the near future": {
    "replace": [
      "soon",
      "shortly"
    ]
  },
  "in the process of": {
    "omit": true,
    "replace": []
  },
  "in view of": {
    "replace": [
      "since"
    ]
  },
  "in view of the above": {
    "replace": [
      "so"
    ]
  },
  "inasmuch as": {
    "replace": [
      "since"
    ]
  },
  "inception": {
    "replace": [
      "start"
    ]
  },
  "incumbent upon": {
    "replace": [
      "must"
    ]
  },
  "indicate": {
    "replace": [
      "show",
      "say",
      "state",
      "write down"
    ]
  },
  "indication": {
    "replace": [
      "sign"
    ]
  },
  "initial": {
    "replace": [
      "first"
    ]
  },
  "initiate": {
    "replace": [
      "start"
    ]
  },
  "inter alia": {
    "omit": true,
    "replace": []
  },
  "interface": {
    "replace": [
      "meet",
      "work with"
    ]
  },
  "interpose no objection": {
    "replace": [
      "don’t object"
    ]
  },
  "is applicable to": {
    "replace": [
      "applies to"
    ]
  },
  "is authorised to": {
    "replace": [
      "may"
    ]
  },
  "is authorized to": {
    "replace": [
      "may"
    ]
  },
  "is in consonance with": {
    "replace": [
      "agrees with",
      "follows"
    ]
  },
  "is responsible for": {
    "omit": true,
    "replace": [
      "handles"
    ]
  },
  "it appears": {
    "replace": [
      "seems"
    ]
  },
  "it is": {
    "omit": true,
    "replace": []
  },
  "it is essential": {
    "replace": [
      "must",
      "need to"
    ]
  },
  "it is requested": {
    "replace": [
      "please"
    ]
  },
  "liaison": {
    "replace": [
      "discussion"
    ]
  },
  "limited number": {
    "replace": [
      "limits"
    ]
  },
  "literally": {
    "omit": true,
    "replace": []
  },
  "magnitude": {
    "replace": [
      "size"
    ]
  },
  "maintain": {
    "replace": [
      "support",
      "keep"
    ]
  },
  "maximum": {
    "replace": [
      "greatest",
      "largest",
      "most"
    ]
  },
  "methodology": {
    "replace": [
      "method"
    ]
  },
  "minimise": {
    "replace": [
      "cut",
      "decrease"
    ]
  },
  "minimize": {
    "replace": [
      "cut",
      "decrease"
    ]
  },
  "minimum": {
    "replace": [
      "least",
      "small",
      "smallest"
    ]
  },
  "modify": {
    "replace": [
      "change"
    ]
  },
  "monitor": {
    "replace": [
      "check",
      "track",
      "watch"
    ]
  },
  "multiple": {
    "replace": [
      "many"
    ]
  },
  "necessitate": {
    "replace": [
      "cause",
      "need"
    ]
  },
  "nevertheless": {
    "replace": [
      "besides",
      "even so",
      "still"
    ]
  },
  "not certain": {
    "replace": [
      "uncertain"
    ]
  },
  "not many": {
    "replace": [
      "few"
    ]
  },
  "not often": {
    "replace": [
      "rarely"
    ]
  },
  "not unless": {
    "replace": [
      "only if"
    ]
  },
  "not unlike": {
    "replace": [
      "alike",
      "similar"
    ]
  },
  "notify": {
    "replace": [
      "let know",
      "tell"
    ]
  },
  "not later than": {
    "replace": [
      "by",
      "before"
    ]
  },
  "notwithstanding": {
    "replace": [
      "despite",
      "in spite of",
      "still"
    ]
  },
  "null and void": {
    "replace": [
      "null",
      "void"
    ]
  },
  "numerous": {
    "replace": [
      "many"
    ]
  },
  "objective": {
    "replace": [
      "aim",
      "goal"
    ]
  },
  "obligate": {
    "replace": [
      "bind",
      "compel"
    ]
  },
  "observe": {
    "replace": [
      "see"
    ]
  },
  "obtain": {
    "replace": [
      "get"
    ]
  },
  "on the contrary": {
    "replace": [
      "but",
      "so"
    ]
  },
  "on the other hand": {
    "omit": true,
    "replace": [
      "but",
      "so"
    ]
  },
  "one particular": {
    "replace": [
      "one"
    ]
  },
  "operate": {
    "replace": [
      "run",
      "use",
      "work"
    ]
  },
  "optimum": {
    "replace": [
      "best",
      "greatest",
      "most"
    ]
  },
  "option": {
    "replace": [
      "choice"
    ]
  },
  "overall": {
    "omit": true,
    "replace": []
  },
  "owing to the fact that": {
    "replace": [
      "because",
      "since"
    ]
  },
  "parameters": {
    "replace": [
      "limits"
    ]
  },
  "participate": {
    "replace": [
      "take part"
    ]
  },
  "particulars": {
    "replace": [
      "details"
    ]
  },
  "pass away": {
    "replace": [
      "die"
    ]
  },
  "perform": {
    "replace": [
      "do"
    ]
  },
  "permit": {
    "replace": [
      "let"
    ]
  },
  "pertaining to": {
    "replace": [
      "about",
      "of",
      "on"
    ]
  },
  "point in time": {
    "replace": [
      "moment",
      "now",
      "point",
      "time"
    ]
  },
  "portion": {
    "replace": [
      "part"
    ]
  },
  "possess": {
    "replace": [
      "have",
      "own"
    ]
  },
  "practicable": {
    "replace": [
      "practical"
    ]
  },
  "preclude": {
    "replace": [
      "prevent"
    ]
  },
  "previous": {
    "replace": [
      "earlier"
    ]
  },
  "previously": {
    "replace": [
      "before"
    ]
  },
  "prior to": {
    "replace": [
      "before"
    ]
  },
  "prioritise": {
    "replace": [
      "focus on",
      "rank"
    ]
  },
  "prioritize": {
    "replace": [
      "focus on",
      "rank"
    ]
  },
  "proceed": {
    "replace": [
      "do",
      "go ahead",
      "try"
    ]
  },
  "procure": {
    "omit": true,
    "replace": [
      "buy",
      "get"
    ]
  },
  "proficiency": {
    "replace": [
      "skill"
    ]
  },
  "promulgate": {
    "replace": [
      "issue",
      "publish"
    ]
  },
  "provide": {
    "replace": [
      "give",
      "offer",
      "say"
    ]
  },
  "provided that": {
    "replace": [
      "if"
    ]
  },
  "provides guidance for": {
    "replace": [
      "guides"
    ]
  },
  "purchase": {
    "replace": [
      "buy",
      "sale"
    ]
  },
  "pursuant to": {
    "replace": [
      "by",
      "following",
      "per",
      "under"
    ]
  },
  "put simply": {
    "omit": true,
    "replace": []
  },
  "readily apparent": {
    "replace": [
      "clear"
    ]
  },
  "refer back": {
    "replace": [
      "refer"
    ]
  },
  "reflect": {
    "replace": [
      "say",
      "show"
    ]
  },
  "regarding": {
    "replace": [
      "about",
      "of",
      "on"
    ]
  },
  "relative to": {
    "replace": [
      "about",
      "on"
    ]
  },
  "relocate": {
    "replace": [
      "move"
    ]
  },
  "remain": {
    "replace": [
      "stay"
    ]
  },
  "remainder": {
    "replace": [
      "rest"
    ]
  },
  "remuneration": {
    "replace": [
      "pay",
      "payment"
    ]
  },
  "render": {
    "replace": [
      "give",
      "make"
    ]
  },
  "represents": {
    "replace": [
      "is"
    ]
  },
  "request": {
    "replace": [
      "ask"
    ]
  },
  "require": {
    "replace": [
      "must",
      "need"
    ]
  },
  "requirement": {
    "replace": [
      "need",
      "rule"
    ]
  },
  "reside": {
    "replace": [
      "live"
    ]
  },
  "residence": {
    "replace": [
      "house"
    ]
  },
  "retain": {
    "replace": [
      "keep"
    ]
  },
  "satisfy": {
    "replace": [
      "meet",
      "please"
    ]
  },
  "selection": {
    "replace": [
      "choice"
    ]
  },
  "set forth in": {
    "replace": [
      "in"
    ]
  },
  "shall": {
    "replace": [
      "must",
      "will"
    ]
  },
  "should you wish": {
    "replace": [
      "if you want"
    ]
  },
  "similar to": {
    "replace": [
      "like"
    ]
  },
  "solicit": {
    "replace": [
      "ask for",
      "request"
    ]
  },
  "span across": {
    "replace": [
      "cross",
      "span"
    ]
  },
  "state-of-the-art": {
    "replace": [
      "latest"
    ]
  },
  "strategise": {
    "replace": [
      "plan"
    ]
  },
  "strategize": {
    "replace": [
      "plan"
    ]
  },
  "submit": {
    "replace": [
      "give",
      "send"
    ]
  },
  "subsequent": {
    "replace": [
      "after",
      "later",
      "next",
      "then"
    ]
  },
  "subsequently": {
    "replace": [
      "after",
      "later",
      "then"
    ]
  },
  "substantial": {
    "replace": [
      "large",
      "much"
    ]
  },
  "successfully complete": {
    "replace": [
      "complete",
      "pass"
    ]
  },
  "sufficient": {
    "replace": [
      "enough"
    ]
  },
  "take action to": {
    "omit": true,
    "replace": []
  },
  "terminate": {
    "replace": [
      "end",
      "stop"
    ]
  },
  "the month of": {
    "omit": true,
    "replace": []
  },
  "the undersigned": {
    "replace": [
      "I"
    ]
  },
  "the use of": {
    "omit": true,
    "replace": []
  },
  "there are": {
    "omit": true,
    "replace": []
  },
  "there is": {
    "omit": true,
    "replace": []
  },
  "therefore": {
    "replace": [
      "so",
      "thus"
    ]
  },
  "thereof": {
    "replace": [
      "its",
      "their"
    ]
  },
  "therein": {
    "replace": [
      "there"
    ]
  },
  "this day and age": {
    "replace": [
      "today"
    ]
  },
  "time period": {
    "replace": [
      "period",
      "time"
    ]
  },
  "timely": {
    "replace": [
      "prompt"
    ]
  },
  "took advantage of": {
    "replace": [
      "preyed on"
    ]
  },
  "transmit": {
    "replace": [
      "send"
    ]
  },
  "type": {
    "omit": true,
    "replace": []
  },
  "transpire": {
    "replace": [
      "happen"
    ]
  },
  "under the provisions of": {
    "replace": [
      "under"
    ]
  },
  "until such time as": {
    "replace": [
      "until"
    ]
  },
  "utilise": {
    "replace": [
      "use"
    ]
  },
  "utilisation": {
    "replace": [
      "use"
    ]
  },
  "utilization": {
    "replace": [
      "use"
    ]
  },
  "utilise": {
    "replace": [
      "use"
    ]
  },
  "utilize": {
    "replace": [
      "use"
    ]
  },
  "validate": {
    "replace": [
      "confirm"
    ]
  },
  "various different": {
    "replace": [
      "different",
      "various"
    ]
  },
  "very": {
    "omit": true,
    "replace": []
  },
  "viable": {
    "replace": [
      "practical",
      "workable"
    ]
  },
  "vice": {
    "replace": [
      "instead of",
      "versus"
    ]
  },
  "warrant": {
    "replace": [
      "call for",
      "permit"
    ]
  },
  "whereas": {
    "replace": [
      "because",
      "since"
    ]
  },
  "whether or not": {
    "replace": [
      "whether"
    ]
  },
  "with reference to": {
    "replace": [
      "about"
    ]
  },
  "with respect to": {
    "replace": [
      "about",
      "on"
    ]
  },
  "with the exception of": {
    "replace": [
      "except for"
    ]
  },
  "witnessed": {
    "replace": [
      "saw",
      "seen"
    ]
  },
  "your office": {
    "replace": [
      "you"
    ]
  }
}

},{}],2:[function(require,module,exports){
'use strict';

var keys = require('object-keys');
var difference = require('lodash.difference');
var nlcstToString = require('nlcst-to-string');
var quotation = require('quotation');
var search = require('nlcst-search');
var position = require('unist-util-position');
var patterns = require('./index.json');

module.exports = simplify;

var list = keys(patterns);

function simplify(options) {
  var ignore = (options || {}).ignore || [];
  var phrases = difference(list, ignore);

  return transformer;

  function transformer(tree, file) {
    search(tree, phrases, finder);

    function finder(match, index, parent, phrase) {
      var pattern = patterns[phrase];
      var replace = pattern.replace;
      var value = nlcstToString(match);
      var quoted = quotation(value, '“', '”');
      var reason;
      var message;

      if (pattern.omit && replace.length === 0) {
        reason = 'Remove ' + quoted;
      } else {
        reason = 'Replace ' + quoted + ' with ' + quotation(replace, '“', '”').join(', ');

        if (pattern.omit) {
          reason += ', or remove it';
        }
      }

      message = file.warn(reason, {
        start: position.start(match[0]),
        end: position.end(match[match.length - 1])
      });

      message.ruleId = phrase.replace(/\s+/g, '-').toLowerCase();
      message.source = 'retext-simplify';
      message.actual = value;
      message.expected = replace;
    }
  }
}

},{"./index.json":1,"lodash.difference":3,"nlcst-search":6,"nlcst-to-string":7,"object-keys":8,"quotation":10,"unist-util-position":11}],3:[function(require,module,exports){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates an array of `array` values not included in the other given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order of result values is determined by the
 * order they occur in the first array.
 *
 * **Note:** Unlike `_.pullAll`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.without, _.xor
 * @example
 *
 * _.difference([2, 1], [2, 3]);
 * // => [1]
 */
var difference = baseRest(function(array, values) {
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
    : [];
});

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = difference;

},{}],4:[function(require,module,exports){
'use strict';

var toString = require('nlcst-to-string');

module.exports = isLiteral;

var single = {
  '-': true, // Hyphen-minus
  '–': true, // En dash
  '—': true, // Em dash
  ':': true, // Colon
  ';': true // Semi-colon
};

/* Pair delimiters. From common sense, and wikipedia:
 * Mostly from https://en.wikipedia.org/wiki/Quotation_mark. */
var pairs = {
  ',': {
    ',': true
  },
  '-': {
    '-': true
  },
  '–': {
    '–': true
  },
  '—': {
    '—': true
  },
  '"': {
    '"': true
  },
  '\'': {
    '\'': true
  },
  '‘': {
    '’': true
  },
  '‚': {
    '’': true
  },
  '’': {
    '’': true,
    '‚': true
  },
  '“': {
    '”': true
  },
  '”': {
    '”': true
  },
  '„': {
    '”': true,
    '“': true
  },
  '«': {
    '»': true
  },
  '»': {
    '«': true
  },
  '‹': {
    '›': true
  },
  '›': {
    '‹': true
  },
  '(': {
    ')': true
  },
  '[': {
    ']': true
  },
  '{': {
    '}': true
  },
  '⟨': {
    '⟩': true
  },
  '「': {
    '」': true
  }
};

/* Check if the node in `parent` at `position` is enclosed
 * by matching delimiters. */
function isLiteral(parent, index) {
  if (!(parent && parent.children)) {
    throw new Error('Parent must be a node');
  }

  if (isNaN(index)) {
    throw new Error('Index must be a number');
  }

  if (
    (!hasWordsBefore(parent, index) && nextDelimiter(parent, index, single)) ||
    (!hasWordsAfter(parent, index) && previousDelimiter(parent, index, single)) ||
    isWrapped(parent, index, pairs)
  ) {
    return true;
  }

  return false;
}

/* Check if the node in `parent` at `position` is enclosed
 * by matching delimiters. */
function isWrapped(parent, position, delimiters) {
  var prev = previousDelimiter(parent, position, delimiters);
  var next;

  if (prev) {
    next = nextDelimiter(parent, position, delimiters[toString(prev)]);
  }

  return Boolean(next);
}

/* Find the previous delimiter before `position` in
 * `parent`. Returns the delimiter node when found. */
function previousDelimiter(parent, position, delimiters) {
  var siblings = parent.children;
  var index = position;
  var result;

  while (index--) {
    result = delimiterCheck(siblings[index], delimiters);

    if (result === null) {
      continue;
    }

    return result;
  }

  return null;
}

/* Find the next delimiter after `position` in
 * `parent`. Returns the delimiter node when found. */
function nextDelimiter(parent, position, delimiters) {
  var siblings = parent.children;
  var index = position;
  var length = siblings.length;
  var result;

  while (++index < length) {
    result = delimiterCheck(siblings[index], delimiters);

    if (result === null) {
      continue;
    }

    return result;
  }

  return null;
}

/* Check if `node` is in `delimiters`. */
function delimiterCheck(node, delimiters) {
  var type = node.type;

  if (type === 'WordNode' || type === 'SourceNode') {
    return false;
  }

  if (type === 'WhiteSpaceNode') {
    return null;
  }

  return toString(node) in delimiters ? node : false;
}

/* Check if there are word nodes before `position`
 * in `parent`. */
function hasWordsBefore(parent, position) {
  return containsWord(parent, 0, position);
}

/* Check if there are word nodes before `position`
 * in `parent`. */
function hasWordsAfter(parent, position) {
  return containsWord(parent, position + 1, parent.children.length);
}

/* Check if parent contains word-nodes between
 * `start` and `end`. */
function containsWord(parent, start, end) {
  var siblings = parent.children;
  var index = start - 1;

  while (++index < end) {
    if (siblings[index].type === 'WordNode') {
      return true;
    }
  }

  return false;
}

},{"nlcst-to-string":7}],5:[function(require,module,exports){
'use strict';

var toString = require('nlcst-to-string');

module.exports = normalize;

var ALL = /[-']/g;
var DASH = /-/g;
var APOSTROPHE = /’/g;
var QUOTE = '\'';
var EMPTY = '';

/* Normalize `value`. */
function normalize(value, options) {
  var settings = options || {};
  var allowApostrophes = settings.allowApostrophes;
  var allowDashes = settings.allowDashes;
  var result = (typeof value === 'string' ? value : toString(value))
    .toLowerCase()
    .replace(APOSTROPHE, QUOTE);

  if (allowApostrophes && allowDashes) {
    return result;
  }

  if (allowApostrophes) {
    return result.replace(DASH, EMPTY);
  }

  if (allowDashes) {
    return result.replace(QUOTE, EMPTY);
  }

  return result.replace(ALL, EMPTY);
}

},{"nlcst-to-string":7}],6:[function(require,module,exports){
'use strict';

/* Dependencies. */
var visit = require('unist-util-visit');
var normalize = require('nlcst-normalize');
var isLiteral = require('nlcst-is-literal');

var own = {}.hasOwnProperty;

/* Expose. */
module.exports = search;

/* Constants. */
var C_SPACE = ' ';
var T_WORD = 'WordNode';
var T_WHITE_SPACE = 'WhiteSpaceNode';

/* Search. */
function search(tree, phrases, handler, options) {
  var settings = options || {};
  var apos = settings.allowApostrophes || options;
  var dashes = settings.allowDashes || false;
  var literals = settings.allowLiterals;
  var config = {allowApostrophes: apos, allowDashes: dashes};
  var byWord = {};
  var length;
  var index;
  var key;
  var firstWord;

  if (!tree || !tree.type) {
    throw new Error('Expected node');
  }

  if (typeof phrases !== 'object') {
    throw new Error('Expected object for phrases');
  }

  length = phrases.length;
  index = -1;

  if ('length' in phrases) {
    while (++index < length) {
      handlePhrase(phrases[index]);
    }
  } else {
    for (key in phrases) {
      handlePhrase(key);
    }
  }

  /* Search the tree. */
  visit(tree, T_WORD, visitor);

  /* Test a phrase.   */
  function test(phrase, position, parent) {
    var siblings = parent.children;
    var node = siblings[position];
    var count = siblings.length;
    var queue = [node];
    var expression = phrase.split(C_SPACE).slice(1);
    var length = expression.length;
    var index = -1;

    /* Move one position forward. */
    position++;

    /* Iterate over `expression`. */
    while (++index < length) {
      /* Allow joining white-space. */
      while (position < count) {
        node = siblings[position];

        if (node.type !== T_WHITE_SPACE) {
          break;
        }

        queue.push(node);
        position++;
      }

      node = siblings[position];

      /* Exit if there are no nodes left, if the
       * current node is not a word, or if the
       * current word does not match the search for
       * value. */
      if (
        !node ||
        node.type !== T_WORD ||
        normalize(expression[index], config) !== normalize(node, config)
      ) {
        return null;
      }

      queue.push(node);
      position++;
    }

    return queue;
  }

  /* Visitor for `WordNode`s.   */
  function visitor(node, position, parent) {
    var word;
    var phrases;
    var length;
    var index;
    var result;

    if (!literals && isLiteral(parent, position)) {
      return;
    }

    word = normalize(node, config);
    phrases = own.call(byWord, word) ? byWord[word] : [];
    length = phrases.length;
    index = -1;

    while (++index < length) {
      result = test(phrases[index], position, parent);

      if (result) {
        handler(result, position, parent, phrases[index]);
      }
    }
  }

  /* Handle a phrase. */
  function handlePhrase(phrase) {
    firstWord = normalize(phrase.split(C_SPACE, 1)[0], config);

    if (own.call(byWord, firstWord)) {
      byWord[firstWord].push(phrase);
    } else {
      byWord[firstWord] = [phrase];
    }
  }
}

},{"nlcst-is-literal":4,"nlcst-normalize":5,"unist-util-visit":12}],7:[function(require,module,exports){
'use strict';

module.exports = nlcstToString;

/* Stringify a NLCST node or list of nodes. */
function nlcstToString(node, separator) {
  var sep = separator || '';
  var values;
  var length;
  var children;

  if (!node || (!('length' in node) && !node.type)) {
    throw new Error('Expected node, not `' + node + '`');
  }

  if (typeof node.value === 'string') {
    return node.value;
  }

  children = 'length' in node ? node : node.children;
  length = children.length;

  /* Shortcut: This is pretty common, and a small performance win. */
  if (length === 1 && 'value' in children[0]) {
    return children[0].value;
  }

  values = [];

  while (length--) {
    values[length] = nlcstToString(children[length], sep);
  }

  return values.join(sep);
}

},{}],8:[function(require,module,exports){
'use strict';

// modified from https://github.com/es-shims/es5-shim
var has = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var slice = Array.prototype.slice;
var isArgs = require('./isArguments');
var isEnumerable = Object.prototype.propertyIsEnumerable;
var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
var dontEnums = [
	'toString',
	'toLocaleString',
	'valueOf',
	'hasOwnProperty',
	'isPrototypeOf',
	'propertyIsEnumerable',
	'constructor'
];
var equalsConstructorPrototype = function (o) {
	var ctor = o.constructor;
	return ctor && ctor.prototype === o;
};
var excludedKeys = {
	$console: true,
	$external: true,
	$frame: true,
	$frameElement: true,
	$frames: true,
	$innerHeight: true,
	$innerWidth: true,
	$outerHeight: true,
	$outerWidth: true,
	$pageXOffset: true,
	$pageYOffset: true,
	$parent: true,
	$scrollLeft: true,
	$scrollTop: true,
	$scrollX: true,
	$scrollY: true,
	$self: true,
	$webkitIndexedDB: true,
	$webkitStorageInfo: true,
	$window: true
};
var hasAutomationEqualityBug = (function () {
	/* global window */
	if (typeof window === 'undefined') { return false; }
	for (var k in window) {
		try {
			if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
				try {
					equalsConstructorPrototype(window[k]);
				} catch (e) {
					return true;
				}
			}
		} catch (e) {
			return true;
		}
	}
	return false;
}());
var equalsConstructorPrototypeIfNotBuggy = function (o) {
	/* global window */
	if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
		return equalsConstructorPrototype(o);
	}
	try {
		return equalsConstructorPrototype(o);
	} catch (e) {
		return false;
	}
};

var keysShim = function keys(object) {
	var isObject = object !== null && typeof object === 'object';
	var isFunction = toStr.call(object) === '[object Function]';
	var isArguments = isArgs(object);
	var isString = isObject && toStr.call(object) === '[object String]';
	var theKeys = [];

	if (!isObject && !isFunction && !isArguments) {
		throw new TypeError('Object.keys called on a non-object');
	}

	var skipProto = hasProtoEnumBug && isFunction;
	if (isString && object.length > 0 && !has.call(object, 0)) {
		for (var i = 0; i < object.length; ++i) {
			theKeys.push(String(i));
		}
	}

	if (isArguments && object.length > 0) {
		for (var j = 0; j < object.length; ++j) {
			theKeys.push(String(j));
		}
	} else {
		for (var name in object) {
			if (!(skipProto && name === 'prototype') && has.call(object, name)) {
				theKeys.push(String(name));
			}
		}
	}

	if (hasDontEnumBug) {
		var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

		for (var k = 0; k < dontEnums.length; ++k) {
			if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
				theKeys.push(dontEnums[k]);
			}
		}
	}
	return theKeys;
};

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			return (Object.keys(arguments) || '').length === 2;
		}(1, 2));
		if (!keysWorksWithArguments) {
			var originalKeys = Object.keys;
			Object.keys = function keys(object) {
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				} else {
					return originalKeys(object);
				}
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

},{"./isArguments":9}],9:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

},{}],10:[function(require,module,exports){
'use strict';

module.exports = quotation;

var C_DEFAULT = '"';

/* Quote text. */
function quotation(value, open, close) {
  var result;
  var index;
  var length;

  open = open || C_DEFAULT;
  close = close || open;

  if (typeof value === 'string') {
    return open + value + close;
  }

  if (typeof value !== 'object' || !('length' in value)) {
    throw new Error('Expected string or array of strings');
  }

  result = [];
  length = value.length;
  index = -1;

  while (++index < length) {
    result[index] = quotation(value[index], open, close);
  }

  return result;
}

},{}],11:[function(require,module,exports){
'use strict';

/* Expose. */
var position = exports;

position.start = positionFactory('start');
position.end = positionFactory('end');

/* Factory to get a position at `type`. */
function positionFactory(type) {
  return pos;

  /* Get a position in `node` at a bound `type`. */
  function pos(node) {
    var pos = (node && node.position && node.position[type]) || {};

    return {
      line: pos.line || null,
      column: pos.column || null,
      offset: isNaN(pos.offset) ? null : pos.offset
    };
  }
}

},{}],12:[function(require,module,exports){
'use strict';

/* Expose. */
module.exports = visit;

/* Visit. */
function visit(tree, type, visitor, reverse) {
  if (typeof type === 'function') {
    reverse = visitor;
    visitor = type;
    type = null;
  }

  one(tree);

  /* Visit a single node. */
  function one(node, index, parent) {
    var result;

    index = index || (parent ? 0 : null);

    if (!type || node.type === type) {
      result = visitor(node, index, parent || null);
    }

    if (node.children && result !== false) {
      return all(node.children, node);
    }

    return result;
  }

  /* Visit children in `parent`. */
  function all(children, parent) {
    var step = reverse ? -1 : 1;
    var max = children.length;
    var min = -1;
    var index = (reverse ? max : min) + step;
    var child;

    while (index > min && index < max) {
      child = children[index];

      if (child && one(child, index, parent) === false) {
        return false;
      }

      index += step;
    }

    return true;
  }
}

},{}]},{},[2])(2)
});